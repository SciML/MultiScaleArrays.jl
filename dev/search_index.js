var documenterSearchIndex = {"docs":
[{"location":"multiscalearray/#API","page":"API","title":"API","text":"","category":"section"},{"location":"multiscalearray/","page":"API","title":"API","text":"AbstractMultiScaleArray\nprint_human_readable","category":"page"},{"location":"multiscalearray/#MultiScaleArrays.AbstractMultiScaleArray","page":"API","title":"MultiScaleArrays.AbstractMultiScaleArray","text":"Defining A MultiScaleModel: The Interface\n\nThe required interface is as follows. Leaf types must extend AbstractMultiScaleArrayLeaf, the highest level of the model or the head extends MultiScaleModelHead, and all intermediate types extend AbstractMultiScaleArray. The leaf has an array values::Vector{B}. Each type above then contains three fields:\n\nnodes::Vector{T}\nvalues::Vector{B}\nend_idxs::Vector{Int}\n\nNote that the ordering of the fields matters. B is the BottomType, which has to be the same as the eltype for the array in the leaf types. T is another AbstractMultiScaleArray. Thus, at each level, an AbstractMultiScaleArray contains some information of its own (values), the next level down in the hierarchy (nodes), and caching for indices (end_idxs). You can add and use extra fields as you please, and you can even make the types immutable.\n\nThe MultiScaleModel API\n\nThe resulting type acts as an array. A leaf type l acts exactly as an array with l[i] == l.values[i]. Higher nodes also act as a linear array. If ln is level n in the hierarchy, then ln.nodes is the vector of level n-1 objects, and ln.values are its “intrinsic values”. There is an indexing scheme on ln, where:\n\nln[i,j,k] gets the kth n-3 object in the jth n-2 object in the ith level n-1 object. Of course, this recurses for the whole hierarchy.\nln[i] provides a linear index through all .nodes and .values values in every lower level and ln.values itself.\n\nThus, ln isa AbstractVector{B}, where B is the eltype of its leaves and all .values's.\n\nIn addition, iterators are provided to make it easy to iterate through levels. For h being the head node, level_iter(h,n) iterates through all level objects n levels down from the top, while level_iter_idx(h,n) is an enumeration (node,y,z) where node are the nth from the head objects, with h[y:z] being the values it holds in the linear indexing.\n\nIndexing and Iteration\n\nThe head node then acts as the king. It is designed to have functionality which mimics a vector in order for usage in DifferentialEquations or Optim. So for example\n\nembryo[12]\n\nreturns the “12th protein”, counting by Embryo > Tissue > Population > Cell in order of the vectors. The linear indexing exists for every AbstractMultiScaleArray. These types act as full linear vectors, so standard operations do the sensical operations:\n\nembryo[10] = 4.0 # changes protein concentration 10\nembryo[2, 3, 1] # Gives the 1st cell in the 3rd population of the second tissue\nembryo[:] # generates a vector of all of the protein concentrations\neachindex(embryo) # generates an iterator for the indices\n\nContinuous models can thus be written at the protein level and will work seamlessly with DifferentialEquations or Optim which will treat it like a vector of protein concentrations. Using the iterators, note that we can get each cell population by looping through 2 levels below the top, so\n\nfor cell in level_iter(embryo, 3)\n    # Do something with the cells!\nend\n\nor the multiple-level iter, which is the one generally used in DifferentialEquations.jl functions:\n\nfor (cell, dcell) in LevelIter(3, embryo, dembryo)\n    # If these are similar structures, `cell` and `dcell` are the similar parts\n    cell_ode(dcell, cell, p, t)\nend\n\nLevelIterIdx can give the indices along with iteration:\n\nfor (cell, y, z) in LevelIterIdx(embryo, 3)\n    # cell = embryo[y:z]\nend\n\nHowever, the interesting behavior comes from event handling. Since embryo will be the “vector” for the differential equation or optimization problem, it will be the value passed to the event handling. MultiScaleArrays includes behavior for changing the structure. For example:\n\ntissue3 = construct(Tissue, deepcopy([population, population2]))\nadd_node!(embryo, tissue3) # Adds a new tissue to the embryo\nremove_node!(embryo, 2, 1) # Removes population 1 from tissue 2 of the embryo\n\nCombined with event handling, this allows for dynamic structures to be derived from low-level behaviors.\n\nHeterogeneous Nodes via Tuples\n\nNote that tuples can be used as well. This allows for type-stable broadcasting with heterogeneous nodes. This could be useful for mixing types inside of the nodes. For example:\n\nstruct PlantSettings{T}\n    x::T\nend\nstruct OrganParams{T}\n    y::T\nend\n\nstruct Organ{B <: Number, P} <: AbstractMultiScaleArrayLeaf{B}\n    values::Vector{B}\n    name::Symbol\n    params::P\nend\n\nstruct Plant{B, S, N <: Tuple{Vararg{Organ{<:Number}}}} <: AbstractMultiScaleArray{B}\n    nodes::N\n    values::Vector{B}\n    end_idxs::Vector{Int}\n    settings::S\nend\n\nstruct Community{B, N <: Tuple{Vararg{Plant{<:Number}}}} <: AbstractMultiScaleArray{B}\n    nodes::N\n    values::Vector{B}\n    end_idxs::Vector{Int}\nend\n\nmutable struct Scenario{B, N <: Tuple{Vararg{Community{<:Number}}}} <:\n               AbstractMultiScaleArrayHead{B}\n    nodes::N\n    values::Vector{B}\n    end_idxs::Vector{Int}\nend\n\norgan1 = Organ([1.1, 2.1, 3.1], :Shoot, OrganParams(:grows_up))\norgan2 = Organ([4.1, 5.1, 6.1], :Root, OrganParams(\"grows down\"))\norgan3 = Organ([1.2, 2.2, 3.2], :Shoot, OrganParams(true))\norgan4 = Organ([4.2, 5.2, 6.2], :Root, OrganParams(1 // 3))\nplant1 = construct(Plant, (deepcopy(organ1), deepcopy(organ2)), Float64[], PlantSettings(1))\nplant2 = construct(Plant, (deepcopy(organ3), deepcopy(organ4)), Float64[],\n                   PlantSettings(1.0))\ncommunity = construct(Community, (deepcopy(plant1), deepcopy(plant2)))\nscenario = construct(Scenario, (deepcopy(community),))\n\n(of course at the cost of mutability).\n\n\n\n\n\n","category":"type"},{"location":"multiscalearray/#MultiScaleArrays.print_human_readable","page":"API","title":"MultiScaleArrays.print_human_readable","text":"print_human_readable(embryo)\n# +|Tissue;                                                 |Tissue\n#  +|Popula;           |Popula;           |Popula;          +|Popula;           |Popula;           |Popula\n#   +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell\n\nprint_human_readable(embryo; NcharPerName = 2)\n# +|Ti;                                   |Ti\n#  +|Po;         |Po;         |Po;        +|Po;         |Po;         |Po\n#   +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce\n\nHere, if the 'AbstractMultiScaleArrayLeaf's contain several fields, you can specify them with fields = [field1,field2,...]\n\nprint_human_readable(embryo; NcharPerName = 2, fields = [:values])\n# +|Ti;                                                                                                                                                                             |Ti\n#  +|Po;                                                       |Po;                                                       |Po;                                                      +|Po;                                                       |Po;                                                       |Po\n#   +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]\n\nif your screen is small, then print a sub-part of the AbstractMultiScaleArray:\n\nprint_human_readable(embryo.nodes[1].nodes[1]; fields = [:values])\n# +values: [1.0, 2.0, 3.0]; values: [3.0, 2.0, 5.0]; values: [4.0, 6.0]\n\n\n\n\n\n","category":"function"},{"location":"multiscalearray/#Extensions","page":"API","title":"Extensions","text":"","category":"section"},{"location":"multiscalearray/","page":"API","title":"API","text":"Note that this only showed the most basic MultiScaleArray. These types can be extended as one pleases. For example, we can change the definition of the cell to have:","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"struct Cell{B} <: AbstractMultiScaleArrayLeaf{B}\n    values::Vector{B}\n    celltype::Symbol\nend","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"Note that the ordering of the fields matters here: the extra fields must come after the standard fields (so for a leaf it comes after values, for a standard multiscale array it would come after nodes,values,end_idxs). Then we'd construct cells with cell3 = Cell([3.0; 2.0; 5.0], :BCell), and can give it a cell type. This information is part of the call, so","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"for (cell, y, z) in level_iter_idx(embryo, 2)\n    f(t, cell, @view embryo[y:z])\nend","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"can allow one to check the cell.celltype in f an apply a different ODE depending on the cell type. You can add fields however you want, so you can use them to name cells and track lineages.","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"Showing the use of values, you just pass it to the constructor. Let's pass it an array of 3 values:","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"tissue = construct(Tissue, deepcopy([population; population2]), [0.0; 0.0; 0.0])","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"We can selectively apply some function on these values via:","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"for (tissue, y, z) in level_iter_idx(embryo, 1)\n    f(t, tissue, @view embryo[y:z])\nend","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"and mutate tis.values in f. For example, we could have","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"function f(du, tissue::Tissue, p, t)\n    du .+= randn(3)\nend","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"applies normal random numbers to the three values. We could use this to add to the model the fact that tissue.values[1:3] are the tissue's position, and f would then be adding Brownian motion.","category":"page"},{"location":"multiscalearray/","page":"API","title":"API","text":"Of course, you can keep going and kind of do whatever you want. The power is yours!","category":"page"},{"location":"#MultiScaleArrays.jl:-High-Performance-Matrix-Exponentiation-and-Products","page":"Home","title":"MultiScaleArrays.jl: High-Performance Matrix Exponentiation and Products","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiScaleArrays.jl allows you to easily build multiple-scale models that are fully compatible with native Julia scientific computing packages like DifferentialEquations.jl or Optim.jl. These models utilize a tree structure to describe phenomena on multiple scales, but the interface allows you to describe equations on different levels, using aggregations from lower levels to describe complex systems. Their structure allows for complex and dynamic models to be developed with only a small performance difference. In the end, they present themselves as an AbstractArray to standard solvers, allowing them to be used in place of a Vector in any appropriately made Julia package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MultiScaleArrays.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MultiScaleArrays\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The usage is best described by an example. Here we build a hierarchy where Embryos contain Tissues which contain Populations which contain Cells, and the cells contain proteins whose concentrations are modeled as simply a vector of numbers (it can be anything linearly indexable).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MultiScaleArrays\nstruct Cell{B} <: AbstractMultiScaleArrayLeaf{B}\n    values::Vector{B}\nend\nstruct Population{T <: AbstractMultiScaleArray, B <: Number} <: AbstractMultiScaleArray{B}\n    nodes::Vector{T}\n    values::Vector{B}\n    end_idxs::Vector{Int}\nend\nstruct Tissue{T <: AbstractMultiScaleArray, B <: Number} <: AbstractMultiScaleArray{B}\n    nodes::Vector{T}\n    values::Vector{B}\n    end_idxs::Vector{Int}\nend\nstruct Embryo{T <: AbstractMultiScaleArray, B <: Number} <: AbstractMultiScaleArrayHead{B}\n    nodes::Vector{T}\n    values::Vector{B}\n    end_idxs::Vector{Int}\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This setup defines a type structure that is both a tree and an array. A picture of a possible version is the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's build a version of this. Using the constructors, we can directly construct leaf types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cell1 = Cell([1.0; 2.0; 3.0])\ncell2 = Cell([4.0; 5.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"and build types higher up in the hierarchy by using the constuct method. The method is construct(T::AbstractMultiScaleArray, nodes, values), though, if values is not given, it's taken to be empty.","category":"page"},{"location":"","page":"Home","title":"Home","text":"cell3 = Cell([3.0; 2.0; 5.0])\ncell4 = Cell([4.0; 6.0])\npopulation = construct(Population, deepcopy([cell1, cell3, cell4]))\npopulation2 = construct(Population, deepcopy([cell1, cell3, cell4]))\npopulation3 = construct(Population, deepcopy([cell1, cell3, cell4]))\ntissue1 = construct(Tissue, deepcopy([population, population2, population3])) # Make a Tissue from Populations\ntissue2 = construct(Tissue, deepcopy([population2, population, population3]))\nembryo = construct(Embryo, deepcopy([tissue1, tissue2])) # Make an embryo from Tissues","category":"page"},{"location":"#Idea","page":"Home","title":"Idea","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The idea behind MultiScaleArrays is simple. The *DiffEq solvers (OrdinaryDiffEq.jl, StochasticDiffEq.jl, DelayDiffEq.jl, etc.) and native optimization packages like Optim.jl in their efficient in-place form all work with any Julia-defined AbstractArray which has a linear index. Thus, to define our multiscale model, we develop a type which has an efficient linear index. One can think of representing cells with proteins as each being an array with values for each protein. The linear index of the multiscale model would be indexing through each protein of each cell. With proper index overloads, one can define a type such that a[i] does just that, and thus it will work in the differential equation solvers. MultiScaleArrays.jl takes that further by allowing one to recursively define an arbitrary n-level hierarchical model which has efficient indexing structures. The result is a type which models complex behavior, but the standard differential equation solvers will work directly and efficiently on this type, making it easy to develop novel models without having to re-develop advanced adaptive/stiff/stochastic/etc. solving techniques for each new model.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
