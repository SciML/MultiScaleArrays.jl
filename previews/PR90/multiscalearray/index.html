<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MultiScaleArrays.jl</title><meta name="title" content="API · MultiScaleArrays.jl"/><meta property="og:title" content="API · MultiScaleArrays.jl"/><meta property="twitter:title" content="API · MultiScaleArrays.jl"/><meta name="description" content="Documentation for MultiScaleArrays.jl."/><meta property="og:description" content="Documentation for MultiScaleArrays.jl."/><meta property="twitter:description" content="Documentation for MultiScaleArrays.jl."/><meta property="og:url" content="https://docs.sciml.ai/MultiScaleArrays/stable/multiscalearray/"/><meta property="twitter:url" content="https://docs.sciml.ai/MultiScaleArrays/stable/multiscalearray/"/><link rel="canonical" href="https://docs.sciml.ai/MultiScaleArrays/stable/multiscalearray/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MultiScaleArrays.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiScaleArrays.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/MultiScaleArrays.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/MultiScaleArrays.jl/blob/master/docs/src/multiscalearray.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiScaleArrays.AbstractMultiScaleArray" href="#MultiScaleArrays.AbstractMultiScaleArray"><code>MultiScaleArrays.AbstractMultiScaleArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Defining A MultiScaleModel: The Interface</strong></p><p>The required interface is as follows. Leaf types must extend AbstractMultiScaleArrayLeaf, the highest level of the model or the head extends MultiScaleModelHead, and all intermediate types extend AbstractMultiScaleArray. The leaf has an array <code>values::Vector{B}</code>. Each type above then contains three fields:</p><ul><li><code>nodes::Vector{T}</code></li><li><code>values::Vector{B}</code></li><li><code>end_idxs::Vector{Int}</code></li></ul><p>Note that the ordering of the fields matters. <code>B</code> is the <code>BottomType</code>, which has to be the same as the eltype for the array in the leaf types. <code>T</code> is another <code>AbstractMultiScaleArray</code>. Thus, at each level, an <code>AbstractMultiScaleArray</code> contains some information of its own (<code>values</code>), the next level down in the hierarchy (<code>nodes</code>), and caching for indices (<code>end_idxs</code>). You can add and use extra fields as you please, and you can even make the types immutable.</p><p><strong>The MultiScaleModel API</strong></p><p>The resulting type acts as an array. A leaf type <code>l</code> acts exactly as an array with <code>l[i] == l.values[i]</code>. Higher nodes also act as a linear array. If <code>ln</code> is level <code>n</code> in the hierarchy, then <code>ln.nodes</code> is the vector of level <code>n-1</code> objects, and <code>ln.values</code> are its “intrinsic values”. There is an indexing scheme on <code>ln</code>, where:</p><ul><li><code>ln[i,j,k]</code> gets the <code>k</code>th <code>n-3</code> object in the <code>j</code>th <code>n-2</code> object in the <code>i</code>th level <code>n-1</code> object. Of course, this recurses for the whole hierarchy.</li><li><code>ln[i]</code> provides a linear index through all <code>.nodes</code> and <code>.values</code> values in every lower level and <code>ln.values</code> itself.</li></ul><p>Thus, <code>ln isa AbstractVector{B}</code>, where <code>B</code> is the eltype of its leaves and all <code>.values</code>&#39;s.</p><p>In addition, iterators are provided to make it easy to iterate through levels. For <code>h</code> being the head node, <code>level_iter(h,n)</code> iterates through all level objects <code>n</code> levels down from the top, while <code>level_iter_idx(h,n)</code> is an enumeration <code>(node,y,z)</code> where <code>node</code> are the <code>n</code>th from the head objects, with <code>h[y:z]</code> being the values it holds in the linear indexing.</p><p><strong>Indexing and Iteration</strong></p><p>The head node then acts as the king. It is designed to have functionality which mimics a vector in order for usage in DifferentialEquations or Optim. So for example</p><pre><code class="language-julia hljs">embryo[12]</code></pre><p>returns the “12th protein”, counting by Embryo &gt; Tissue &gt; Population &gt; Cell in order of the vectors. The linear indexing exists for every <code>AbstractMultiScaleArray</code>. These types act as full linear vectors, so standard operations do the sensical operations:</p><pre><code class="language-julia hljs">embryo[10] = 4.0 # changes protein concentration 10
embryo[2, 3, 1] # Gives the 1st cell in the 3rd population of the second tissue
embryo[:] # generates a vector of all of the protein concentrations
eachindex(embryo) # generates an iterator for the indices</code></pre><p>Continuous models can thus be written at the protein level and will work seamlessly with DifferentialEquations or Optim which will treat it like a vector of protein concentrations. Using the iterators, note that we can get each cell population by looping through 2 levels below the top, so</p><pre><code class="language-julia hljs">for cell in level_iter(embryo, 3)
    # Do something with the cells!
end</code></pre><p>or the multiple-level iter, which is the one generally used in DifferentialEquations.jl functions:</p><pre><code class="language-julia hljs">for (cell, dcell) in LevelIter(3, embryo, dembryo)
    # If these are similar structures, `cell` and `dcell` are the similar parts
    cell_ode(dcell, cell, p, t)
end</code></pre><p><code>LevelIterIdx</code> can give the indices along with iteration:</p><pre><code class="language-julia hljs">for (cell, y, z) in LevelIterIdx(embryo, 3)
    # cell = embryo[y:z]
end</code></pre><p>However, the interesting behavior comes from event handling. Since <code>embryo</code> will be the “vector” for the differential equation or optimization problem, it will be the value passed to the event handling. MultiScaleArrays includes behavior for changing the structure. For example:</p><pre><code class="language-julia hljs">tissue3 = construct(Tissue, deepcopy([population, population2]))
add_node!(embryo, tissue3) # Adds a new tissue to the embryo
remove_node!(embryo, 2, 1) # Removes population 1 from tissue 2 of the embryo</code></pre><p>Combined with event handling, this allows for dynamic structures to be derived from low-level behaviors.</p><p><strong>Heterogeneous Nodes via Tuples</strong></p><p>Note that tuples can be used as well. This allows for type-stable broadcasting with heterogeneous nodes. This could be useful for mixing types inside of the nodes. For example:</p><pre><code class="language-julia hljs">struct PlantSettings{T}
    x::T
end
struct OrganParams{T}
    y::T
end

struct Organ{B &lt;: Number, P} &lt;: AbstractMultiScaleArrayLeaf{B}
    values::Vector{B}
    name::Symbol
    params::P
end

struct Plant{B, S, N &lt;: Tuple{Vararg{&lt;:Organ{&lt;:Number}}}} &lt;: AbstractMultiScaleArray{B}
    nodes::N
    values::Vector{B}
    end_idxs::Vector{Int}
    settings::S
end

struct Community{B, N &lt;: Tuple{Vararg{&lt;:Plant{&lt;:Number}}}} &lt;: AbstractMultiScaleArray{B}
    nodes::N
    values::Vector{B}
    end_idxs::Vector{Int}
end

mutable struct Scenario{B, N &lt;: Tuple{Vararg{&lt;:Community{&lt;:Number}}}} &lt;:
               AbstractMultiScaleArrayHead{B}
    nodes::N
    values::Vector{B}
    end_idxs::Vector{Int}
end

organ1 = Organ([1.1, 2.1, 3.1], :Shoot, OrganParams(:grows_up))
organ2 = Organ([4.1, 5.1, 6.1], :Root, OrganParams(&quot;grows down&quot;))
organ3 = Organ([1.2, 2.2, 3.2], :Shoot, OrganParams(true))
organ4 = Organ([4.2, 5.2, 6.2], :Root, OrganParams(1 // 3))
plant1 = construct(Plant, (deepcopy(organ1), deepcopy(organ2)), Float64[], PlantSettings(1))
plant2 = construct(Plant, (deepcopy(organ3), deepcopy(organ4)), Float64[],
                   PlantSettings(1.0))
community = construct(Community, (deepcopy(plant1), deepcopy(plant2)))
scenario = construct(Scenario, (deepcopy(community),))</code></pre><p>(of course at the cost of mutability).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/MultiScaleArrays.jl/blob/1ee8780f484e92613debbdeb811b0f51494dd1ef/src/MultiScaleArrays.jl#L13-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiScaleArrays.print_human_readable" href="#MultiScaleArrays.print_human_readable"><code>MultiScaleArrays.print_human_readable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_human_readable(embryo)
# +|Tissue;                                                 |Tissue
#  +|Popula;           |Popula;           |Popula;          +|Popula;           |Popula;           |Popula
#   +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell; +Cell; Cell; Cell

print_human_readable(embryo; NcharPerName = 2)
# +|Ti;                                   |Ti
#  +|Po;         |Po;         |Po;        +|Po;         |Po;         |Po
#   +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce; +Ce; Ce; Ce</code></pre><p>Here, if the &#39;AbstractMultiScaleArrayLeaf&#39;s contain several fields, you can specify them with fields = [field1,field2,...]</p><pre><code class="language-julia hljs">print_human_readable(embryo; NcharPerName = 2, fields = [:values])
# +|Ti;                                                                                                                                                                             |Ti
#  +|Po;                                                       |Po;                                                       |Po;                                                      +|Po;                                                       |Po;                                                       |Po
#   +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]; +va: [1.0, 2.0, 3.0]; va: [3.0, 2.0, 5.0]; va: [4.0, 6.0]</code></pre><p>if your screen is small, then print a sub-part of the AbstractMultiScaleArray:</p><pre><code class="language-julia hljs">print_human_readable(embryo.nodes[1].nodes[1]; fields = [:values])
# +values: [1.0, 2.0, 3.0]; values: [3.0, 2.0, 5.0]; values: [4.0, 6.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/MultiScaleArrays.jl/blob/1ee8780f484e92613debbdeb811b0f51494dd1ef/src/print_human_readable.jl#L53-L81">source</a></section></article><h3 id="Extensions"><a class="docs-heading-anchor" href="#Extensions">Extensions</a><a id="Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions" title="Permalink"></a></h3><p>Note that this only showed the most basic MultiScaleArray. These types can be extended as one pleases. For example, we can change the definition of the cell to have:</p><pre><code class="language-julia hljs">struct Cell{B} &lt;: AbstractMultiScaleArrayLeaf{B}
    values::Vector{B}
    celltype::Symbol
end</code></pre><p>Note that the ordering of the fields matters here: the extra fields must come after the standard fields (so for a leaf it comes after <code>values</code>, for a standard multiscale array it would come after <code>nodes,values,end_idxs</code>). Then we&#39;d construct cells with <code>cell3 = Cell([3.0; 2.0; 5.0], :BCell)</code>, and can give it a cell type. This information is part of the call, so</p><pre><code class="language-julia hljs">for (cell, y, z) in level_iter_idx(embryo, 2)
    f(t, cell, @view embryo[y:z])
end</code></pre><p>can allow one to check the <code>cell.celltype</code> in <code>f</code> an apply a different ODE depending on the cell type. You can add fields however you want, so you can use them to name cells and track lineages.</p><p>Showing the use of <code>values</code>, you just pass it to the constructor. Let&#39;s pass it an array of 3 values:</p><pre><code class="language-julia hljs">tissue = construct(Tissue, deepcopy([population; population2]), [0.0; 0.0; 0.0])</code></pre><p>We can selectively apply some function on these <code>values</code> via:</p><pre><code class="language-julia hljs">for (tissue, y, z) in level_iter_idx(embryo, 1)
    f(t, tissue, @view embryo[y:z])
end</code></pre><p>and mutate <code>tis.values</code> in <code>f</code>. For example, we could have</p><pre><code class="language-julia hljs">function f(du, tissue::Tissue, p, t)
    du .+= randn(3)
end</code></pre><p>applies normal random numbers to the three values. We could use this to add to the model the fact that <code>tissue.values[1:3]</code> are the tissue&#39;s position, and <code>f</code> would then be adding Brownian motion.</p><p>Of course, you can keep going and kind of do whatever you want. The power is yours!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 3 May 2024 07:55">Friday 3 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
